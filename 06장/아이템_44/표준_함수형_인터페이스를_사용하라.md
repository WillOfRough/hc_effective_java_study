# [표준 함수형 인터페이스를 사용하라]
자바 8부터 람다를 지원하면서 상위 클래스의 메소드를 재정의해 원하는 동작을 구현하는 템플릿 메소드 패턴의 매력이 크게 줄었다.  
이를 대체하는 현대적인 해법은 같은 효과의 함수 객체를 받는 정적 팩토리나 생성자를 제공하는 것이다.  
이 말을 일반화해서 말하자면 함수 객체를 매개변수로 받는 생성자와 메소드를 더 많이 만들어야 한다는 말이다.  

## LinkedHashMap의 removeEldestEntry() 를 개선해보자.
다음은 LinkedHashMap 의 인스턴스 메소드인 removeEldestEntry() 이다. 이를 함수형 인터페이스를 이용해 개선해보자.
LinkedHashMap 클래스의 protected 메서드인 removeEldesetEntry를 재정의 하면 캐시로 사용할 수 있다.
맵에 새로운 키를 추가하는 put 메서드는 true가 반환되면 맵에서 가장 오래된 원소를 제거한다.

```JAVA
// 이 코드에서는 size() 가 100을 초과할 경우 가장 오래된 원소를 하나씩 제거한다.
protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
    return size() > 100;
}
```
위 removeEldestEntry 선언을 보면 이 함수 객체는 Map<K,V>를 받아 boolean을 반환해야 할 것 같지만 꼭 그렇지 않다.  
removeEldestEntry는 size()를 호출해 맵 안의 원소 수를 알아내는데 이는 removeEldestEntryrk 인스턴스 메서드이기 때문에 가능하다.  
함수 객체는 클래스의 인스턴스 메서드가 아니며, 생성자를 통해 설정된 후 removeEldestEntry 메서드에서 호출되기 때문에 클래스 인스턴스와 별도로 동작하므로 맵은 자기 자신도 함수 객체에 건네줘야 한다.

이를 반영한 함수형 인터페이스는 다음과 같다.

```JAVA
//코드 44-1
@FunctionalInterface
interface EldestEntryRemovalFunction<K,V> {
    // 전달 받은 map의 size를 계산해서 처리할 수 있도록 함
    boolean remove(Map<K,V> map, Map.Entry<K,V> eldest);
}
```

## 표준 함수형 인터페이스를 잘 활용하자.
위 코드 44-1의 인터페이스도 잘 동작하기는 하지만, 자바 표준 라이브러리에 이미 같은 모양의 인터페이스가 준비되어 있기 때문에 굳이 사용할 필요는 없다.  
필요한 용도에 맞는게 있다면 직접 구현하지 말고 표준 함수형 인터페이스를 활용하자.  

*`java.util.function` 패키지에는 총 43개의 표준 인터페이스를 제공한다. 다 외우기엔 수도 많고 규칙성도 부족하지만 실무에서 자주 쓰이는 함수형 인터페이스 중 상당수를 제공하고 필요할 때 찾아 쓸 만큼은 범용적인 이름을 사용하므로 이를 잘 이용하자.*  

표준 함수형 인터페이스의 대부분은 기본 타입만 지원한다. 그렇다고 **기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자.** (아이템 61)

## 코드를 직접 작성해야 할 때는 언제인가?
구조적으로 똑같은 표준 함수형 인터페이스가 있더라도 직접 작성해야만 할 때가 있다. 아래 세가지 중 하나 이상을 만족한다면 전용 항수형 인터페이스를 구현할지 신중히 고민해야 한다.  
* 자주 쓰이며 이름 자체가 용도를 명확히 설명해준다.  
* 반드시 따라야 하는 규약이 있다.  
* 유용한 디폴트 메소드를 제공할 수 있다.

또한 자신이 작성하는게 **인터페이스**임을 명심하고, 아주 주의해서 설계해야 한다.([아이템21](04장/아이템_21/인터페이스는_구현하는_쪽을_생각해_설계하라.md))

## 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하라.
코드 44-1의 EldestEntryRemovalFunction 인터페이스에 @FunctionalInterface 애너테이션이 있음을 주목하자.  
이 애너테이션을 사용하는 이유는 @Override를 사용하는 이유와 비슷하다.  
* 해당 클래스의 코드를 보는 사람들에게 이 인터페이스가 람다용으로 설계된 것임을 알려준다.
* 해당 인터페이스가 추상 메소드를 오직 하나만 가지고 있어야 컴파일되게 해준다.
* 유지보수 과정에서 누군가 실수로 이 인터페이스에 메소드를 추가하지 못하게 막는다.

## 함수형 인터페이스를 사용할 때 주의할 점
**1. 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지 말자.**  
표준 함수형 인터페이스 대부분은 기본 타입만 지원한다. 그렇다고 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자. 오토박싱, 오토언박싱에 의한 성능 저하가 발생하기 때문이다.

**2. 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지 말자.**  
이유는 클라이언트에게 불필요한 모호함만 안겨주기 때문이다. 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메소드들을 다중 정의하는 경우, Client에서 원하는 메소드를 호출하기 위해 해당 함수형 인터페이스 타입으로 형변환해줘야 할 때가 많이 발생한다.  

```JAVA
public interface ExecutorService extends Executor {
    <T> Future<T> submit(Callable<T> task);
    <T> Future<T> submit(Runnable task, T result); 
    <T> Future<T> submit(Runnable task);
}
```

## 정리
* 자바도 람다를 지원하므로 API를 설계할 때 람다도 염두에 두어야 한다.  
* 즉, 입력값과 반환값에 함수형 인터페이스 타입을 활용하라.  
* 보통은 java.util.function 패키지의 표준 함수형 인터페이스를 사용하는 것이 가장 좋은 선택이다.  
* 흔하진 않지만 직접 새로운 함수형 인터페이스를 만들어 쓰는 편이 나을 수도 있음을 잊지 말자. 