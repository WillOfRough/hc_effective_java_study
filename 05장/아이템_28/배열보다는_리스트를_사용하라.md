# [배열보다는 리스트를 사용하라]

## 배열과 제네릭은 잘 어울리지 않는다.
**1. 배열은 공변, 제네릭은 불공변이다.**  
* 여기서 공변이란 '함께 변한다' 는 뜻이다.  
* Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다.  
* 반면에 제네릭은 불공변으로 서로 다른 타입 Type1과 Type2가 있을 때 List은 List의 하위 타입도 아니고 상위 타입도 아니다.  
다음 코드는 문법상 허용되는 코드지만 런타임에 실패한다.
```JAVA
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다."; // ArrayStoreException을 던진다.
```
하지만 다음 코드는 문법에 맞지 않는다.
```JAVA
List<Object> ol = new ArrayList<Long>();  // 호환되지 않는 타입이다.
o.add("타입이 달라 넣을 수 없다.");
```
* 어느 쪽이든 Long용 저장소에 String을 넣을 수 없다. 다만 배열에서는 그 실수를 런타임에야 알게 되지만 리스트를 사용하면 컴파일할 때 바로 알 수 있다.

**2. 배열은 실체화(reify)된다.**  

* 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.  
* 그래서 위 첫 번째 예제에서 보듯 Long 배열에 String을 넣으려 하면 ArrayStoreException이 발생한다.
* 반면, 제네릭은 타입 정보가 런타임에는 소거(erasure) 된다.  
* 이는 원소 타입을 컴파일 타임에만 검사하며 런타임에는 알 수조차 없다는 뜻이다.

## 배열은 제네릭으로 만들 수 없다.
* 배열과 제네릭은 위의 차이로 인해 잘 어우러지지 못하며, 배열을 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.  
* 즉, 코드를 new List<E>[], new List<String>[], new E[] 과 같이 작성하면 컴파일 시 제네릭 배열 생성 오류를 일으킨다.

### 제네릭 배열을 만들지 못하게 막은 이유


## 골격 구현 클래스 작성법

## 단순 구현(simple implementation)
