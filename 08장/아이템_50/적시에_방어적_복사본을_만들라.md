# [적시에 방어적 복사본을 만들라]
의도했든, 의도하지 않았든 간에 외부에서는 내가 작성한 클래스의 불변식을 깨뜨릴 수 있다. 따라서 **클라이언트가 내가 작성한 클래스의 불변식을 깨뜨릴 수 있다고 가정하고 방어적으로 프로그래밍을 해야 한다.** 예컨대 아래 클래스는 기간(period)을 표현하는 클래스로 start와 end 값을 불변으로 만들 계획이었다.

```JAVA
public class Period {
    private final Date start;
    private final Date end;
    /**
     * @param start 시작 시각
     * @param end 종료 시각, 시작 시각보다 뒤여야한다.
     * @throw IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생
     * @throw NullPointerException start나 end가 null일 때 발생
     */
    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0)
            throw new IllegalArgumentException(start + "가 " + end + "보다 늦다.");

        this.start = start;
        this.end = end;
    }

    public Date start() { return start; }

    public Date end() { return end; }
}
```
하지만 외부에서는 어렵지 않게 불변식을 깨뜨릴 수 있다.

```JAVA
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78); // p의 내부를 수정했다.
```

## 외부에서 클래스를 수정하지 못하게 하려면 방어적 복사를 해야 한다.
외부 공격으로부터 인스턴스의 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사(depensive copy) 해야 한다. 즉, 인스턴스 안에서는 매개변수의 값으로 원본이 아닌 복사본을 사용한다.  
```JAVA
//수정한 생성자-매개변수의 방어적 복사본을 만든다.
public Period(Date start, Date end) {
    // 매개변수의 복사본을 만들어 내부에 저장한다.
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());

    if (this.start.compareTo(this.end) > 0)
        throw new IllegalArgumentException(this.start + "가 " + this.end + "보다 늦다.");
}
```
위의 생성자를 사용하면앞서의 공격은 더 이상 Period에 위협이 되지 않는다.  
* **매개변수의 유효성을 검사([아이템49](08장/아이템_49/매개변수가_유효한지_검사하라.md))하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사한 점에 주목한다.**  
순서가 부자연스러워 보이지만 반드시 이렇게 작성해야 한다. 멀티스레드 환경이라면 유효성을 검사한 후 복사본을 만드는 찰나의 취약한 시간에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다. 이러한 공격 방법을 검사시점/사용시점(time-of-check/time-of-use) 공격 또는 줄여서 TOCTOU 공격이라 한다. 
* **방어적 복사본을 만들 때 clone을 사용하지 않는다.**  
매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안된다.  Date는 final이 아니므로 clone이 Date가 정의한 게 아닐 수 있다. 즉 악의적인 하위 클래스의 인스턴스를 반환할 수도 있게 되므로 공격자에게 Period 인스턴스 자체를 맡기는 꼴이 된다.  

## 접근자에서도 방어적 복사가 되도록 수정해보자.
클라이언트의 악의적인 접근을 방지하기 위해 생성자와 마찬가지로 접근자에서도 방어적 복사를 수행해야 한다. 접근자 메서드가 내부의 가변 정보를 직접 드러내기 때문에 Period 인스턴스는 여전히 변경 가능하기 때문이다. 

```JAVA
//Period 인스턴스를 향한 두 번째 공격
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
p.end().setYear(78); //p의 내부를 변경함
```
위와 같은 공격을 막아내려면 접근자가 가변 필드의 방어적 복사본을 반환하면 된다.

```JAVA
public Date start() {
    return new Date(start.getTime());
}

public Date end() {
    return new Date(end.getTime());
}
```
이렇게 하면 모든 필드가 객체 안에 완벽하게 캡슐화 되었다.  
생성자와 달리 접근자 메서드에서는 방어적 복사에 clone을 사용해도 된다. Period가 가지고 있는 Date 객체는 java.util.Date임이 확실하기 때문이다. 그렇더라도 인스턴스를 복사하는 데는 일반적으로 생성자나 정적 팩터리를 쓰는게 좋다.  

## 방어적 복사의 목적이 불변 객체를 만들기 위해서만은 아니다.
* 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항상 그 객체가 잠재적으로 변경될 수 있는지 생각해야 한다. 변경될 수 있는 객체라면 그 객체가 클래스에 넘겨진 뒤 임의로 변경되어도 문제가 없을지 따져봐야한다. 확신할 수 없다면 복사본을 만들어 저장해야한다. 
* 내부 객체를 클라이언트에 건네주기 전에 방어적 복사본을 만드는 이유도 마찬가지다. 클래스가 불변이든 가변이든, 가변인 내부 객체를 클라이언트에 반환할 때는 반드시 심사숙고 해야하며, 안심할 수 없다면 방어적 복사본을 수행해야 한다. 길이가 1 이상인 배열은 무조건 가변임을 잊지 말자. 따라서 내부에서 사용하는 배열을 클라이언트에 반환할 때는 항상 방어적 복사를 수행하거나, 배열의 불변 뷰를 반환해야 한다.[아이템15](04장/아이템_15/클래스와_멤버의_접근_권한을_최소화하라.md)

**이상의 모든 작업에서 우리는 "되도록 불변 객체를 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어는다"는 교훈을 얻는다.** [아이템17](04장/아이템_17/변경_가능성을_최소화하라.md)  
* 이 때 자바 8을 사용하는 경우, Date 대신 불변인 Instant 혹은 LocalDateTime, ZonedDateTime 을 사용하면 문제를 해결할 수 있다. (Date 는 낡은 API니 새로운 코드를 작성할 때는 더 이상 사용하면 안된다.)  
* 또는 Date.getTime() 이 반환하는 long 정수를 사용하는 방법도 있다.

### 항상 방어적 복사를 해야하는 것은 아니다.
방어적 복사에는 성능 저하가 따르고, 항상 쓸 수 있는 것도 아니기 때문에 특정 상황에서는 방어적 복사를 생략해도 된다.  
**1. 클래스와 그 클라이언트가 상호 신뢰할 수 있을 때**  
* 호출자가 컴포넌트 내부를 수정하지 않으리라 확신하는 경우 방어적 복사를 생략할 수 있다.  
* 이 경우 가변 객체를 전달 받는 메소드나 생성자에서 해당 매개변수나 반환값을 수정하지 말아야 함을 명확히 문서화하는 게 좋다.  

**2. 불변식이 깨지더라도 그 영향이 오직 호출한 클라이언트로만 국한될 때**  
* 예컨대 래퍼 클래스의 경우 클라이언트는 래퍼에 넘긴 객체에 여전히 직접 접근이 가능하다. 따라서 래퍼의 불변식을 쉽게 파괴할 수 있지만 그 영향을 오직 클라이언트 자신만 받게 된다.  

## 정리
* 입력 매개변수로 받거나 반환하는 구성요소가 가변이라면 반드시 방어적으로 복사해야 한다.  
* 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성 요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하도록 하자.