# [추상 클래스보다는 인터페이스를 우선하라]

자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스 두 가지다.  
둘의 가장 큰 차이는 자바는 단일 상속만 지원하므로 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다.  
반면 인터페이스가 선언한 메소드를 모두 정의하고 그 일반 규약을 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.

## 추상 클래스보다 인터페이스를 사용했을 때의 장점
**1. 인터페이스는 기존 클래스에 손쉽게 구현(추가)할 수 있다.**  

* 인터페이스가 요구하는 메소드를 추가하고, implements 만 추가하면 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다.  
ex. AutoCloseable 등의 인터페이스가 추가되었을 때 자바 표준 라이브러리의 수많은 기존 클래스가 이 인터페이스들을 구현한 채 릴리즈됐다.  
* 반면에 기존 클래스 위에 새로운 추상 클래스를 끼워넣기는 어려운 게 일반적이다.  
* 두 클래스가 같은 추상 클래스를 확장하길 원한다면, 그 추상 클래스는 계층구조상 두 클래스의 공통 조상이어야 한다.  
안타깝게도 이 방식은 클래스 계층 구조에 커다란 혼란을 일으키는데, 새로 추가된 추상 클래스의 모든 자손이 이를 상속하게 되는 것이다. (그렇게 하는 것이 적절하지 않은 상황에서도 강제로 말이다.)

**2. 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다.**  

    믹스인이란 클래스가 구현할 수 있는 타입으로 믹스인을 구현한 클래스에 원래의 '주된 타입' 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.  
    ex. Comparable 은 자신을 구현한 클래스의 인스턴스들끼리는 순서를 정할 수 있다고 선언하는 믹스인 인터페이스다.  

**3. 인터페이스로는 계층 구조가 없는 타입 프레임워크를 만들 수 있다.**
**4. 래퍼클래스 관용구와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 된다.**
**5. 디폴트 메소드를 제공해 프로그래머의 일감을 덜어줄 수 있다.**


인터페이스는 여러 인터페이스를 상속 받을 수 있기 때문에 

추상클래스와 인터페이스는 자주 비교가 되곤 한다. 보통 인터페이스는 타입을 정의할 때 사용하고, 추상 클래스는 보통 인터페이스의 구현체를 일부 제공할 때 사용하는데, 추상클래스를 상속해서 구현을 하기 보다는 인터페이스를 우선해서 사용하라는 이야기다. 추상 클래스에 비해서 인터페이스가 가지는 장점이 많은데, 오로지 하나의 추상클래스만 상속을 받을 수 있기 때문에 추상 클래스를 상속하는 식으로 기능 제공을 하면 제약이 심해짐. 해당 클래스가 이미 다른 클래스를 상속받고 있을 수도 있고, 여러 클래스가 동일한 클래스를 상속 받아야하는 경우도 있는데 이미 계층 구조가 만들어져 있는 경우는 어려워 진다. 이러한 이유로 인터페이스를 사용하면 자유롭게 여러개를 구현하게 만들 수도 있고, 기존 클래스가 어떤 클래스를 상속받고 있던지 관계없이 기능을 추가할 수 있기 때문에 인터페이스를 사용하라는 것. 자바 8부터 디폴트 메서드를 추가할 수 있게 되는데, 간단한 예제를 보자.(timeclient와 그를 상속받는 simpletimeclient)
timeclient 에서 인터페이스가 있는데, 만약 이 인터페이스를 변경하고 싶을 때가 있을텐데 그때 잘 쓸수 있는것이 디폴트메소드이다.

```JAVA
/**
 * 반복자를 이용해 순회하면서 주어진 Predicate에 각 원소가 인수로 주어졌을 때 
 * true를 반환하는 경우 그 원소는 제거된다. 
 */
default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean removed = false;
    final Iterator<E> each = iterator();
    while (each.hasNext()) {
        if (filter.test(each.next())) {
            each.remove();
            removed = true;
        }
    }
    return removed;
}
```
위 코드도 범용적이지만, 모든 Collection 구현체와 잘어우러지는 것은 아니다. 그 예로 apache.commons.collections4의 SynchronizedCollection이 있다.  
이 클래스는 모든 메서드에서 주어진 락 객체로 동기화 한 후 내부 컬랙션 객체에 기능을 위임하는 래퍼클래스이다.(클라이언트가 제공한 객체로 락을 거는 기능)
```JAVA
public class SynchronizedCollection<E> implements Collection<E>, Serializable {
    private final Collection<E> collection;
    protected final Object lock;

    public static <T> SynchronizedCollection<T> synchronizedCollection(Collection<T> coll) {
        return new SynchronizedCollection(coll);
    }

    public boolean add(E object) {
        synchronized(this.lock) {
            return this.decorated().add(object);
        }
    }

    ...
}
```
그런데 SynchronizedCollection은 removeIf 를 재정의하고 있지 않다. (책이 쓰여진 시점에는 제공되지 않았지만 현재는 제공됨)  
따라서 이 클래스를 자바 8과 사용하여 removeIf의 디폴트 구현을 물려받게 되면 모든 메서드 호출을 알아서 동기화해주지 못한다. (removeIf의 구현은 동기화에 대해 아무것도 모르므로 락 객체를 사용할 수 없기 때문에)  
이 때문에 SynchronizedCollection 인스턴스를 여러 스레드가 공유하는 상황에서 한 스레드가 removeIf를 호출하면 ConcurrentModificationException이 발생하거나 다른 예상치 못한 결과가 나올 수 있다.

## 디폴트 메소드 작성 시 주의할 점
* 디폴트 메소드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다.  
기존 인터페이스에 디폴트 메소드로 새 메소드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다. 추가하려면 기존 구현체와 충돌하지 않을지 심사숙고 한다.  
* 반면에 새로운 인터페이스를 만드는 경우는 표준적인 메소드 구현을 제공하는 데 아주 유용한 수단이며, 그 인터페이스를 더 쉽게 구현해 활용할 수 있게끔 해준다.
* 디폴트 메소드는 인터페이스로부터 메소드를 제거하거나 기존 메소드의 시그니처를 수정하는 용도가 아님을 명심해야 한다. 이런 형태로 인터페이스를 변경하게 되면 반드시 기존 클라이언트를 망가뜨리게 된다.

## 인터페이스를 설계할 때 세심한 주의를 기울이기
디폴트 메서드라는 도구가 생겼더라도 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다.  
새로운 인터페이라면 릴리즈 전에 반드시 테스트를 거쳐야 한다. 개발자들은 나름의 방식으로 구현할 것이니 나도 최소한 세 가지는 다른 방식으로 구현해봐야 한다.  
또한 각 인터페이스의 인스턴스를 다양한 작업에 활용하는 클라이언트도 여러 개 만들어봐야 한다.  
이러한 작업들을 거치면 인터페이스를 릴리즈하기 전에 결함을 찾아낼 수 있다.  
인터페이스를 릴리즈한 후라도 결함을 수정하는 게 가능한 경우도 있겠지만, 절대 그 가능성에 기대서는 안된다.